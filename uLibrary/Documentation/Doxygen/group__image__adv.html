<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Advanced</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.2 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
  </ul>
</div>
<h1>Advanced<br>
<small>
[<a class="el" href="group__images.html">Images</a>]</small>
</h1>More advanced routines for manipulating images.  
<a href="#_details">More...</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__image__adv.html#gfb2f95aae285b1876e3e8868969d4d1a">ulImageIsPaletted</a>(img)&nbsp;&nbsp;&nbsp;(img-&gt;format &gt;= UL_PF_PAL5_A3 &amp;&amp; img-&gt;format &lt;= UL_PF_PAL3_A5)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__image__adv.html#ga223941ecdf28a4399547b11d056794f">ulImageSetRotCenter</a>(img)&nbsp;&nbsp;&nbsp;((img)-&gt;centerX = ulAbs((img)-&gt;offsetX1 - (img)-&gt;offsetX0) &gt;&gt; 1, (img)-&gt;centerY = ulAbs((img)-&gt;offsetY1 - (img)-&gt;offsetY0) &gt;&gt; 1)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__image__adv.html#gdbfc4e29d495cf00d2ad8b494407f5c5">ulGetImageLineAddr</a>(img, y)&nbsp;&nbsp;&nbsp;((char*)((img)-&gt;texture) + (y)*(((img)-&gt;sysSizeX * ul_pixelWidth[(img)-&gt;format])&gt;&gt;3))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__image__adv.html#g5d6c82ba117d43320c0034c1ce85a005">ulGetImagePixelAddr</a>(img, x, y)&nbsp;&nbsp;&nbsp;((char*)((img)-&gt;texture) + ((((y)*(img)-&gt;sysSizeX + (x)) * ul_pixelWidth[(img)-&gt;format])&gt;&gt;3))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__image__adv.html#ga2c16f8015876d32a96a10c1ef86a9b7">ulGetImageTotalSize</a>(img)&nbsp;&nbsp;&nbsp;(((img)-&gt;sysSizeX * (img)-&gt;sysSizeY * ul_pixelWidth[(img)-&gt;format]) &gt;&gt; 3)</td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__image__adv.html#g0580237c99d54890d933561542d93a41">ulLockImage</a> (<a class="el" href="struct_u_l___i_m_a_g_e.html">UL_IMAGE</a> *img, <a class="el" href="group__images.html#g55bd7b56d67c4f0854e5ebfa1bd82f41">UL_LOCK_REASON</a> lockReason)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__image__adv.html#gffa4c41787fe069bd4ec74d47935715f">ulUnlockImage</a> (<a class="el" href="struct_u_l___i_m_a_g_e.html">UL_IMAGE</a> *img, <a class="el" href="group__images.html#g55bd7b56d67c4f0854e5ebfa1bd82f41">UL_LOCK_REASON</a> lockReason)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__image__adv.html#g390df053733779183d3c9c3b85309cae">ulSetImagePixel</a> (<a class="el" href="struct_u_l___i_m_a_g_e.html">UL_IMAGE</a> *img, int x, int y, int pixelValue)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__image__adv.html#gecfdf1958eecd34a1fd5137129f2efad">ulGetImagePixel</a> (<a class="el" href="struct_u_l___i_m_a_g_e.html">UL_IMAGE</a> *img, int x, int y)</td></tr>

<tr><td colspan="2"><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">u8&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__image__adv.html#g1f07579ed2c9b0fd4c69d3a013b5838c">ul_firstPaletteColorOpaque</a></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
More advanced routines for manipulating images. 
<p>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="gfb2f95aae285b1876e3e8868969d4d1a"></a><!-- doxytag: member="drawing.h::ulImageIsPaletted" ref="gfb2f95aae285b1876e3e8868969d4d1a" args="(img)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ulImageIsPaletted          </td>
          <td>(</td>
          <td class="paramtype">img&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;(img-&gt;format &gt;= UL_PF_PAL5_A3 &amp;&amp; img-&gt;format &lt;= UL_PF_PAL3_A5)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieves wether an image needs a palette or not based on its pixel format 
</div>
</div><p>
<a class="anchor" name="ga223941ecdf28a4399547b11d056794f"></a><!-- doxytag: member="drawing.h::ulImageSetRotCenter" ref="ga223941ecdf28a4399547b11d056794f" args="(img)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ulImageSetRotCenter          </td>
          <td>(</td>
          <td class="paramtype">img&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;((img)-&gt;centerX = ulAbs((img)-&gt;offsetX1 - (img)-&gt;offsetX0) &gt;&gt; 1, (img)-&gt;centerY = ulAbs((img)-&gt;offsetY1 - (img)-&gt;offsetY0) &gt;&gt; 1)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Defines the rotation center of an image to the center of it. 
</div>
</div><p>
<a class="anchor" name="gdbfc4e29d495cf00d2ad8b494407f5c5"></a><!-- doxytag: member="drawing.h::ulGetImageLineAddr" ref="gdbfc4e29d495cf00d2ad8b494407f5c5" args="(img, y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ulGetImageLineAddr          </td>
          <td>(</td>
          <td class="paramtype">img,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">y&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;((char*)((img)-&gt;texture) + (y)*(((img)-&gt;sysSizeX * ul_pixelWidth[(img)-&gt;format])&gt;&gt;3))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return a pointer to the beginning of an image line pixel data. 
</div>
</div><p>
<a class="anchor" name="g5d6c82ba117d43320c0034c1ce85a005"></a><!-- doxytag: member="drawing.h::ulGetImagePixelAddr" ref="g5d6c82ba117d43320c0034c1ce85a005" args="(img, x, y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ulGetImagePixelAddr          </td>
          <td>(</td>
          <td class="paramtype">img,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">x,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">y&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;((char*)((img)-&gt;texture) + ((((y)*(img)-&gt;sysSizeX + (x)) * ul_pixelWidth[(img)-&gt;format])&gt;&gt;3))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return a pointer to the corresponding pixel of an image.<p>
Please note that some image formats are not byte-boundary, like 2 or 4 bits formats. You'll have to so some more work to set a single pixel on these images. 
</div>
</div><p>
<a class="anchor" name="ga2c16f8015876d32a96a10c1ef86a9b7"></a><!-- doxytag: member="drawing.h::ulGetImageTotalSize" ref="ga2c16f8015876d32a96a10c1ef86a9b7" args="(img)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ulGetImageTotalSize          </td>
          <td>(</td>
          <td class="paramtype">img&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;(((img)-&gt;sysSizeX * (img)-&gt;sysSizeY * ul_pixelWidth[(img)-&gt;format]) &gt;&gt; 3)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the total size (in bytes) of an image. 
</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g0580237c99d54890d933561542d93a41"></a><!-- doxytag: member="drawing.h::ulLockImage" ref="g0580237c99d54890d933561542d93a41" args="(UL_IMAGE *img, UL_LOCK_REASON lockReason)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* ulLockImage           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_l___i_m_a_g_e.html">UL_IMAGE</a> *&nbsp;</td>
          <td class="paramname"> <em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__images.html#g55bd7b56d67c4f0854e5ebfa1bd82f41">UL_LOCK_REASON</a>&nbsp;</td>
          <td class="paramname"> <em>lockReason</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Locks an image so that you can access its contents in software. Returns a pointer to the image contents. It's only useful if your image is in VRAM, but you can call this function even if your image is in RAM, it's a safe way to access your image.<p>
You must provide the reason for which you want to lock your image: UL_LOCK_PIXELS (pixel data) or UL_LOCK_PALETTE (palette data). The corresponding pointer will be returned. You can lock both elements with 2 successive calls.<p>
Note: only one image can be locked at a time. Always unlock everything from an image before locking another one.<p>
Note 2: images should be locked for a very small time, especially if they're stored in VRAM, because this will also lock the video memory, making the GPU unable to read from it. If you're doing that during a render, the screen may display transparent bands due to a rendering failure. 
</div>
</div><p>
<a class="anchor" name="gffa4c41787fe069bd4ec74d47935715f"></a><!-- doxytag: member="drawing.h::ulUnlockImage" ref="gffa4c41787fe069bd4ec74d47935715f" args="(UL_IMAGE *img, UL_LOCK_REASON lockReason)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ulUnlockImage           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_l___i_m_a_g_e.html">UL_IMAGE</a> *&nbsp;</td>
          <td class="paramname"> <em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__images.html#g55bd7b56d67c4f0854e5ebfa1bd82f41">UL_LOCK_REASON</a>&nbsp;</td>
          <td class="paramname"> <em>lockReason</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unlocks a locked image. Always unlock the your images shortly after having locked them! You must provide the same reason as the one you used when locking it. If you lock both elements of a single image, you should lock them at the same time, and also unlock them at the same time.<p>
Example: <div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> *tetxurepointer = <a class="code" href="group__image__adv.html#g0580237c99d54890d933561542d93a41">ulLockImage</a>(image, <a class="code" href="group__images.html#gg55bd7b56d67c4f0854e5ebfa1bd82f411116947d3b226223bc51fc2cf5baed28" title="Access to image pixel data.">UL_LOCK_PIXELS</a>);
<span class="keywordtype">void</span> *palettepointer = <a class="code" href="group__image__adv.html#g0580237c99d54890d933561542d93a41">ulLockImage</a>(image, <a class="code" href="group__images.html#gg55bd7b56d67c4f0854e5ebfa1bd82f418dab6a0f5a714b0dc20013a8444f6f86" title="Access to image palette data.">UL_LOCK_PALETTE</a>);
[use your pointers]
<a class="code" href="group__image__adv.html#gffa4c41787fe069bd4ec74d47935715f">ulUnlockImage</a>(image, <a class="code" href="group__images.html#gg55bd7b56d67c4f0854e5ebfa1bd82f418dab6a0f5a714b0dc20013a8444f6f86" title="Access to image palette data.">UL_LOCK_PALETTE</a>);
<a class="code" href="group__image__adv.html#gffa4c41787fe069bd4ec74d47935715f">ulUnlockImage</a>(image, <a class="code" href="group__images.html#gg55bd7b56d67c4f0854e5ebfa1bd82f411116947d3b226223bc51fc2cf5baed28" title="Access to image pixel data.">UL_LOCK_PIXELS</a>);
</pre></div> 
</div>
</div><p>
<a class="anchor" name="g390df053733779183d3c9c3b85309cae"></a><!-- doxytag: member="drawing.h::ulSetImagePixel" ref="g390df053733779183d3c9c3b85309cae" args="(UL_IMAGE *img, int x, int y, int pixelValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ulSetImagePixel           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_l___i_m_a_g_e.html">UL_IMAGE</a> *&nbsp;</td>
          <td class="paramname"> <em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>pixelValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Draws a single pixel on an image. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pixelValue</em>&nbsp;</td><td>The raw pixel value.<ul>
<li>A 16-bit color with alpha in 5551</li><li>A 15-bit color value without alpha in 5550</li><li>A 8-bit color palette index in PAL8</li><li>A 5-bit color palette index in PAL5_A3 with the 3 MSB set to the alpha value</li><li>A 3-bit color palette index in PAL3_A5 with the 5 MSB set to the alpha value</li></ul>
</td></tr>
  </table>
</dl>
Note that this function is not optimized for speed, but should be okay for most uses. If you need a very fast mean to do it, then you'll have to write your own renderer function, which will be able to draw several pixels at once depending on the image format. 
</div>
</div><p>
<a class="anchor" name="gecfdf1958eecd34a1fd5137129f2efad"></a><!-- doxytag: member="drawing.h::ulGetImagePixel" ref="gecfdf1958eecd34a1fd5137129f2efad" args="(UL_IMAGE *img, int x, int y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ulGetImagePixel           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_l___i_m_a_g_e.html">UL_IMAGE</a> *&nbsp;</td>
          <td class="paramname"> <em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the raw value of a pixel on an image. Same considerations as ulSetImagePixel apply.<p>
The return value will be a color if it's a 15 or 16-bit image, it will be a value (palette entry) in other cases. 
</div>
</div><p>
<hr><h2>Variable Documentation</h2>
<a class="anchor" name="g1f07579ed2c9b0fd4c69d3a013b5838c"></a><!-- doxytag: member="drawing.h::ul_firstPaletteColorOpaque" ref="g1f07579ed2c9b0fd4c69d3a013b5838c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8 <a class="el" href="group__image__adv.html#g1f07579ed2c9b0fd4c69d3a013b5838c">ul_firstPaletteColorOpaque</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Treats the first color palette as opaque. When enabled, image loading routines (GIF/PNG/...) will NEVER use the color 0 except if it's transparent (color key and so on). Values:<ul>
<li>0: disabled (default), color 0 will not be used by loading routines if no color of the image matches the defined color key or if color keying is disabled. Only colors 1 to 3/15/255 will be used instead.</li><li>1: partially enabled, keeps the same palette order as loaded images. Thus, the first color of paletted PNG/GIF images will always appear as transparent, no matter their value.<ul>
<li>2: fully enabled: hardware will process color 0 as opaque, but it may cause problems because transparency may be rendered incorrectly in formats like UL_PF_PAL3_A5 (to be tested). </li></ul>
</li></ul>

</div>
</div><p>
<hr size="1"><address style="text-align: right;"><small>Generated on Sat Jul 14 23:39:33 2007 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.2 </small></address>
</body>
</html>
